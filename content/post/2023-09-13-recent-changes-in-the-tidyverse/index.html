---
title: Recent updates to tidyverse functions
author: Matt Russell
date: '2023-09-14'
slug: []
categories:
  - Analytics
tags:
  - analytics
  - data science
  - R
  - tidyverse
---



<center>
<img src="hex-tidyverse.png" width="250" />
</center>
<div id="section" class="section level1">
<h1></h1>
<p>I recently watched the video <a href="https://youtu.be/KsBBRHAgAhM?si=Csp18DrhZhFe7r8x">“Teaching the tidyverse in 2023”</a> by Mine Çetinkaya-Rundel to learn more about recent changes to my favorite R package. I learned quite a bit of new tricks and techniques for my everyday R coding and sharing a few of them here.</p>
<p>I’ll use the <code>elm</code> data set from the <strong>stats4nr</strong> package as I work through a few examples in the post. This data set contains observations on 333 cedar elm trees (<em>Ulmus crassifolia</em> Nutt.) measured in Austin, Texas:</p>
<pre class="r"><code>library(tidyverse)

#devtools::install_github(&quot;mbrussell/stats4nr&quot;)
library(stats4nr)

data(elm)</code></pre>
<p>Here are a few of the key points I took away from the video.</p>
<div id="the-native-pipe-works." class="section level3">
<h3>The native pipe works.</h3>
<p>R has a native pipe denoted as <code>|&gt;</code>. The pipe is shorthand for saying “then.” In other words, you can say “use my data frame, then make a new variable in it.” Now, the native pipe is a part of the the tidyverse.</p>
<p>If you’re a longtime user of the tidyverse, you might have been using <code>%&gt;%</code>. Now, the pipe integrates with base R. For example, the code:</p>
<pre class="r"><code>elm |&gt; 
  summary()</code></pre>
<p>provides the same output as:</p>
<pre class="r"><code>elm %&gt;% 
  summary()</code></pre>
<p>If you’re using RStudio, you can change the setting to use the native pipe by going to <strong>Tools</strong> -&gt; <strong>Global Options</strong>, -&gt; <strong>Code</strong>:</p>
</div>
</div>
<div id="section-1" class="section level1">
<h1></h1>
<center>
<img src="pipe_operator.png" width="500" />
</center>
</div>
<div id="section-2" class="section level1">
<h1></h1>
<div id="the-lubridate-package-is-now-a-part-of-the-core-tidyverse." class="section level3">
<h3>The lubridate package is now a part of the core tidyverse.</h3>
<p>If your data contain a lot of dates and times, the <strong>lubridate</strong> package is your best friend. This package is now a part of the tidyverse and no longer needs to be called separately.</p>
<p>The <strong>lubridate</strong> package has several functions for working with date and time variables. For example, we can change strings of dates into year-month-date formats with the <code>ymd()</code> or <code>dmy()</code> functions:</p>
<pre class="r"><code>my_date &lt;- &quot;20230914&quot;

my_date2 &lt;- &quot;14092023&quot;

ymd(my_date)</code></pre>
<pre><code>## [1] &quot;2023-09-14&quot;</code></pre>
<pre class="r"><code>dmy(my_date2)</code></pre>
<pre><code>## [1] &quot;2023-09-14&quot;</code></pre>
</div>
<div id="easy-ways-to-use-a-function-in-one-package-thats-named-the-same-in-another-package" class="section level3">
<h3>Easy ways to use a function in one package that’s named the same in another package</h3>
<p>Several packages in R use functions with the same name, which can present problems when you tell R to use a function. You will often see this as a warning when you first load a library into your R session when there are functions of the same name from other packages. As <a href="https://www.tidyverse.org/blog/2023/08/teach-tidyverse-23/">Mine mentions in her post</a>, R will often <em>silently</em> choose the function from a package to use.</p>
<p>For example, the <code>lag()</code> function is available in both <strong>dplyr</strong> and the base R <strong>stats</strong> package. If we wanted to explicitly tell R to use this function from the <strong>dplyr</strong> package, we could write <code>dplyr::lag()</code>. But that could be repetitive if we use that function multiple times in our data analysis.</p>
<p>Now with the <code>conflicts_prefer()</code> function from the <strong>conflicted</strong> package, you can tell R to use a specific function once, then forget about it for the rest of your analysis. For example,</p>
<pre class="r"><code>library(conflicted)
conflicts_prefer(dplyr::lag)</code></pre>
<pre><code>## [conflicted] Will prefer dplyr::lag over any other package.</code></pre>
<p>This will choose the <code>lag()</code> function from <strong>dplyr</strong>. For example, say we wanted to use it to lag the tree diameter measurement in the <strong>elm</strong> data set:</p>
<pre class="r"><code>elm |&gt; 
  mutate(DIA2 = lag(DIA))</code></pre>
<pre><code>## # A tibble: 333 × 9
##    STATUSCD  SPCD   DIA    HT CROWN_HEIGHT CROWN_DIAM_WIDE UNCOMP_CROWN_RATIO
##       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt;              &lt;dbl&gt;
##  1        1   838   5      32         19.2              19                 60
##  2        1   838   5      25         11.3              11                 45
##  3        1   838   5.1    21          6.3              10                 30
##  4        1   838   5.1    27         18.9              13                 70
##  5        1   838   5.1    22         18.7               6                 85
##  6        1   838   5.1    27         18.9              11                 70
##  7        1   838   5.2    29         11.6              12                 40
##  8        1   838   5.2    20          7                 9                 35
##  9        1   838   5.2    18         17.8              12                 99
## 10        1   838   5.2    17          6                17                 35
## # ℹ 323 more rows
## # ℹ 2 more variables: CROWN_CLASS_CD &lt;dbl&gt;, DIA2 &lt;dbl&gt;</code></pre>
</div>
<div id="new-updates-to-joining-variables" class="section level3">
<h3>New updates to joining variables</h3>
<p>It seems like joining data sets is one of the most common tasks I do in my work, and tidyverse has new ways of doing this. The <code>join_by()</code> function can take the place of the <code>by =</code> statements. The good thing is there is no need to quote variable names anymore in the <code>by()</code> statement!</p>
<p>For example, say we have a data set that contains the codes for all open grown trees in the <strong>elm</strong> data set:</p>
<pre class="r"><code>crown_class &lt;- tribble(
  ~crown_code, ~CROWN_CLASS_NAME,
  1, &quot;Open grown&quot;,
  2, &quot;Not open grown&quot;,
  3, &quot;Not open grown&quot;,
  4, &quot;Not open grown&quot;,
  5, &quot;Not open grown&quot;
)</code></pre>
<p>Then we could join this to the elm data set. What I love about <code>join_by()</code> is there’s no need to have the variable name the same in both data sets that you want to merge by. Note that the code indicating crown class is named <em>CROWN_CLASS_CD</em> in the <strong>elm</strong> data set and <em>crown_code</em> in the <strong>crown_class</strong> data set. It can be joined by expressing the double equal sign <code>==</code>:</p>
<pre class="r"><code>elm |&gt;
  left_join(crown_class, join_by(CROWN_CLASS_CD == crown_code)) |&gt; 
  select(DIA, HT, CROWN_CLASS_CD, CROWN_CLASS_NAME)</code></pre>
<pre><code>## # A tibble: 333 × 4
##      DIA    HT CROWN_CLASS_CD CROWN_CLASS_NAME
##    &lt;dbl&gt; &lt;dbl&gt;          &lt;dbl&gt; &lt;chr&gt;           
##  1   5      32              4 Not open grown  
##  2   5      25              5 Not open grown  
##  3   5.1    21              5 Not open grown  
##  4   5.1    27              3 Not open grown  
##  5   5.1    22              3 Not open grown  
##  6   5.1    27              5 Not open grown  
##  7   5.2    29              3 Not open grown  
##  8   5.2    20              4 Not open grown  
##  9   5.2    18              3 Not open grown  
## 10   5.2    17              3 Not open grown  
## # ℹ 323 more rows</code></pre>
<p>The join functions also have more ways to identify unmatched rows in your data. If this is of interest to you, explore the <code>unmatched = “drop”</code> and <code>unmatched = “error”</code> statements.</p>
</div>
<div id="new-function-to-group-variables" class="section level3">
<h3>New function to group variables</h3>
<p>A typical summary operation with <strong>dplyr</strong> code to obtain a mean and standard deviation of a variable might go something like:</p>
<pre class="r"><code>elm |&gt; 
  group_by(CROWN_CLASS_CD) |&gt; 
  summarize(mean_DIA = mean(DIA),
            sd_DIA = sd(DIA))</code></pre>
<pre><code>## # A tibble: 5 × 3
##   CROWN_CLASS_CD mean_DIA sd_DIA
##            &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;
## 1              1     7.5    3.29
## 2              2    17.6    7.56
## 3              3    10.9    5.10
## 4              4     7.77   2.72
## 5              5     7.09   2.04</code></pre>
<p>Now, you can add a <code>.by</code> statement to add the grouping variable within the same call:</p>
<pre class="r"><code>elm |&gt; 
  summarize(
    mean_DIA = mean(DIA),
    sd_DIA = sd(DIA),
    .by = CROWN_CLASS_CD
    )</code></pre>
<pre><code>## # A tibble: 5 × 3
##   CROWN_CLASS_CD mean_DIA sd_DIA
##            &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;
## 1              4     7.77   2.72
## 2              5     7.09   2.04
## 3              3    10.9    5.10
## 4              1     7.5    3.29
## 5              2    17.6    7.56</code></pre>
<p>I’m not sure how much this new technique will help in my analysis (and I’m wondering why the order of crown classes is different for both approaches), but it does make sense to keep the functions within the same call. This may be particularly useful if there are more operations happening after the grouping.</p>
</div>
<div id="new-function-to-split-columns-and-rows" class="section level3">
<h3>New function to split columns and rows</h3>
<p>New functions are available to help separate columns and rows into multiple columns or rows. For example, say we have a variable in the <strong>elm</strong> data set that separates the diameter and height measurements with a comma:</p>
<pre class="r"><code>elm |&gt; 
  mutate(DIA_HT = paste0(DIA, &quot;,&quot;, HT)) |&gt; 
  select(DIA, HT, DIA_HT)</code></pre>
<pre><code>## # A tibble: 333 × 3
##      DIA    HT DIA_HT
##    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 
##  1   5      32 5,32  
##  2   5      25 5,25  
##  3   5.1    21 5.1,21
##  4   5.1    27 5.1,27
##  5   5.1    22 5.1,22
##  6   5.1    27 5.1,27
##  7   5.2    29 5.2,29
##  8   5.2    20 5.2,20
##  9   5.2    18 5.2,18
## 10   5.2    17 5.2,17
## # ℹ 323 more rows</code></pre>
<p>The <code>separate_wider_delim()</code> function separates columns into multiple one based on a delimiter. You can then rename the variables directly in the <code>names =</code> statement:</p>
<pre class="r"><code>elm |&gt; 
  mutate(DIA_HT = paste0(DIA, &quot;,&quot;, HT)) |&gt; 
  separate_wider_delim(DIA_HT, 
                       delim = &quot;,&quot;,
                       names = c(&quot;DIA2&quot;, &quot;HT2&quot;)) |&gt; 
  select(DIA2, HT2)</code></pre>
<pre><code>## # A tibble: 333 × 2
##    DIA2  HT2  
##    &lt;chr&gt; &lt;chr&gt;
##  1 5     32   
##  2 5     25   
##  3 5.1   21   
##  4 5.1   27   
##  5 5.1   22   
##  6 5.1   27   
##  7 5.2   29   
##  8 5.2   20   
##  9 5.2   18   
## 10 5.2   17   
## # ℹ 323 more rows</code></pre>
<p>This can be a handy function, particularly for those that work with character strings that need to split them up into component parts. Note that the original variable that you separate (i.e., the <em>DIA_HT</em> variable) is dropped after you use the function.</p>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>Check out these new features in the tidyverse and try them in your own analysis. These new features are particularly well adapted for new learners of R/the tidyverse given they make more intuitive sense (and speed up performance). Let me know if any of the new techniques presented here help in your own data analysis.</p>
<p>–</p>
<p><em>By Matt Russell. <a href="mailto:matt@arbor-analytics.com">Email Matt</a> with any questions or comments.</em></p>
</div>
</div>
